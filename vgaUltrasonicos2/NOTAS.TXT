Tengo el siguiente codigo vhdl, que es un componente del archivo principal:

--
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;

ENTITY sonic IS
	PORT ( 
		clk : IN STD_LOGIC;
		sensor_eco : buffer STD_LOGIC; 
		led, sensor_disp : buffer STD_LOGIC;
		Ucm, Dcm : buffer STD_LOGIC_VECTOR (6 DOWNTO 0)
	);
END sonic;

ARCHITECTURE Behavioral OF sonic IS
 
    SIGNAL cuenta : STD_LOGIC_VECTOR(16 DOWNTO 0) := (OTHERS => '0');
	SIGNAL contador_s : INTEGER RANGE 0 TO 125000000 := 0;
	
	--Maneja la distancia mas cercana antes del STOP
	SIGNAL centimetros : STD_LOGIC_VECTOR(15 DOWNTO 0) := (OTHERS => '0');
	SIGNAL centimetros_unid : STD_LOGIC_VECTOR(3 DOWNTO 0) := (OTHERS => '0');
	SIGNAL centimetros_dece : STD_LOGIC_VECTOR(3 DOWNTO 0) := (OTHERS => '0');

	--Señales que se pasaran para el pingpong
	SIGNAL sal_unid : STD_LOGIC_VECTOR(3 DOWNTO 0) := (OTHERS => '0');
	SIGNAL sal_dece : STD_LOGIC_VECTOR(3 DOWNTO 0) := (OTHERS => '0');
	
	--Para sincronizar las señales de eco
	SIGNAL eco_pasado : STD_LOGIC := '0';
	SIGNAL eco_sinc : STD_LOGIC := '0';
	SIGNAL eco_nsinc : STD_LOGIC := '0';
	SIGNAL espera : STD_LOGIC := '0';
 

BEGIN

	Trigger : PROCESS (clk) BEGIN
		IF rising_edge(clk) THEN
			
		IF espera = '0' THEN
				IF cuenta = 500 THEN --Por cada 500 pulssos de reloj se revisa el sensor ultrasonico (Señal Trigger)
					sensor_disp <= '0';
					espera <= '1';
					cuenta <= (OTHERS => '0');
				ELSE
					sensor_disp <= '1';
					cuenta <= cuenta + 1;
				END IF;

			--Calculo de la distancia	y contador de pulsos
			ELSIF eco_pasado = '0' AND eco_sinc = '1' THEN
				cuenta <= (OTHERS => '0');
				centimetros <= (OTHERS => '0');
				centimetros_unid <= (OTHERS => '0');
				centimetros_dece <= (OTHERS => '0');

			--Si se se mide la distancia del objeto que se encuentre en 4 bits
			ELSIF eco_pasado = '1' AND eco_sinc = '0' THEN
				sal_unid <= centimetros_unid;
				sal_dece <= centimetros_dece;

			--Cada 10 unidades se registra un aumento de 10 cm	
			ELSIF cuenta = 2900 - 1 THEN
				IF centimetros_unid = 9 THEN
					centimetros_unid <= (OTHERS => '0');
					centimetros_dece <= centimetros_dece + 1;
				ELSE --Si no son 10 unidades, el contador solo aumenta a unidades en 1cm
					centimetros_unid <= centimetros_unid + 1;
				END IF;
				centimetros <= centimetros + 1;
				cuenta <= (OTHERS => '0');
				IF centimetros = 3448 THEN  
					espera <= '0';
				END IF;
			ELSE
				cuenta <= cuenta + 1;
			END IF;
			eco_pasado <= eco_sinc;
			eco_sinc <= eco_nsinc;
			eco_nsinc <= sensor_eco;
		END IF;
	END PROCESS;

	DecoUnidades : PROCESS (sal_unid)
	BEGIN
		IF sal_unid = X"0" THEN
			Ucm <= "1000000";
		ELSIF sal_unid = X"1" THEN
			Ucm <= "1111001";
		ELSIF sal_unid = X"2" THEN
			Ucm <= "0100100";
		ELSIF sal_unid = X"3" THEN
			Ucm <= "0110000";
		ELSIF sal_unid = X"4" THEN
			Ucm <= "0011001";
		ELSIF sal_unid = X"5" THEN
			Ucm <= "0010010";
		ELSIF sal_unid = X"6" THEN
			Ucm <= "0000010";
		ELSIF sal_unid = X"7" THEN
			Ucm <= "0111000";
		ELSIF sal_unid = X"8" THEN
			Ucm <= "0000000";
		ELSIF sal_unid = X"9" THEN
			Ucm <= "0011000";
		ELSE
			Ucm <= "1111111";
		END IF;
	END PROCESS;

	DecoDecenas : PROCESS (sal_dece)
	BEGIN
		IF sal_dece = X"0" THEN
			Dcm <= "1000000";
		ELSIF sal_dece = X"1" THEN
			Dcm <= "1111001";
		ELSIF sal_dece = X"2" THEN
			Dcm <= "0100100";
		ELSIF sal_dece = X"3" THEN
			Dcm <= "0110000";
		ELSIF sal_dece = X"4" THEN
			Dcm <= "0011001";
		ELSIF sal_dece = X"5" THEN
			Dcm <= "0010010";
		ELSIF sal_dece = X"6" THEN
			Dcm <= "0000010";
		ELSIF sal_dece = X"7" THEN
			Dcm <= "0111000";
		ELSIF sal_dece = X"8" THEN
			Dcm <= "0000000";
		ELSIF sal_dece = X"9" THEN
			Dcm <= "0011000";
		ELSE
			Dcm <= "1111111";
		END IF;
	END PROCESS; 
	
	Salidas : PROCESS (sal_unid, sal_dece, clk)
	BEGIN 
		IF rising_edge(clk) THEN
			IF (sal_unid = X"4" AND (sal_dece >= X"2" AND sal_dece <= X"6")) THEN
				led <= '1'; 
			ELSE
				led <= '0'; 
			END IF;
		END IF;
	END PROCESS;

	
	
	

END Behavioral;
--

Archivo principal:
--
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL; 

ENTITY sonicos IS
	PORT ( 
		clk : IN STD_LOGIC;
		
		sensor_eco1 : buffer STD_LOGIC; 
		led1, sensor_disp1 : buffer STD_LOGIC;
		Ucm1, Dcm1 : buffer STD_LOGIC_VECTOR (6 DOWNTO 0);
		
		sensor_eco2 : buffer STD_LOGIC; 
		led2, sensor_disp2 : buffer STD_LOGIC;
		Ucm2, Dcm2 : buffer STD_LOGIC_VECTOR (6 DOWNTO 0)
	);
END sonicos;

ARCHITECTURE Behavioral OF sonicos IS 

	--Asignacion de Pines
	ATTRIBUTE chip_pin : STRING;
	ATTRIBUTE chip_pin OF clk : SIGNAL IS "P11"; 
	ATTRIBUTE chip_pin OF led1 : SIGNAL IS "B11";
	ATTRIBUTE chip_pin OF sensor_disp1 : SIGNAL IS "W6";
	ATTRIBUTE chip_pin OF sensor_eco1 : SIGNAL IS "V5";   
	ATTRIBUTE chip_pin OF Ucm1 : SIGNAL IS "C17,D17,E16,C16,C15,E15,C14"; 
	ATTRIBUTE chip_pin OF Dcm1 : SIGNAL IS "B17,A18,A17,B16,E18,D18,C18";

	
	ATTRIBUTE chip_pin OF led2 : SIGNAL IS "A8";
	ATTRIBUTE chip_pin OF sensor_disp2 : SIGNAL IS "AB2";
	ATTRIBUTE chip_pin OF sensor_eco2 : SIGNAL IS "AA2";   
	ATTRIBUTE chip_pin OF Ucm2 : SIGNAL IS "F20,F19,H19,J18,E19,E20,F18";
	ATTRIBUTE chip_pin OF Dcm2 : SIGNAL IS "N20,N19,M20,N18,L18,K20,J20";
	

	component sonic IS
	PORT ( 
		clk :   STD_LOGIC; 
		sensor_eco :  buffer STD_LOGIC; 
		led, sensor_disp : buffer  STD_LOGIC;
		Ucm, Dcm : buffer  STD_LOGIC_VECTOR (6 DOWNTO 0)
	);
	END component sonic; 
 

BEGIN

	ultra1 :sonic
		port map(
			clk 		=> clk,
			sensor_eco  => sensor_eco1,
			led 		=> led1, 
			sensor_disp => sensor_disp1,
			Ucm		    => Ucm1,
			Dcm 		=> Dcm1
		)
	;
	
	ultra2 :sonic
		port map(
			clk => clk,
			sensor_eco   => sensor_eco2,
			led 		 => led2, 
			sensor_disp  => sensor_disp2,
			Ucm 		 => Ucm2,
			Dcm 		 => Dcm2
		)
	;
	  

	
	
	

END Behavioral;
--

El codigo no marca errores y se puede cargar en la FPGA, pero no enciende el led ni toma medidas los ultrasonicos.
La idea es que el codigo controle dos sensores ultrasonicos de forma independiente, que midan las distancias
y que en cierto rangos enciendan un led.
Mi sospecha es que  en: 
sonic IS
	PORT ( 
		clk :   STD_LOGIC; 
		sensor_eco :  buffer STD_LOGIC; 
		led, sensor_disp : buffer  STD_LOGIC;
		Ucm, Dcm : buffer  STD_LOGIC_VECTOR (6 DOWNTO 0)
	);
Algunos puertos tienen que ser de solo salida, como el del led, y no buffer

Quiero que me digas que puede estar fallando y como arreglarlo, tanto con la explicacion del porque , como el codigo que lo arregla
